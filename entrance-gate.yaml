substitutions:
  device_name: entrance-gate
  friendly_name: Portail

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "Portail connecté"
  
esp8266:
  board: esp8285
  restore_from_flash: true

# Import du composant impulse_cover
external_components:
  - source: github://AntorFr/esphome-impulse-cover
    components: [ impulse_cover ]
    refresh: 1s

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  use_address: ${device_name}.intra.sberard.fr

  ap:
    ssid: ${device_name}
    password: !secret ap_password

logger:
  level: WARN
  
api:
  reboot_timeout: 15min
  encryption:
    key: !secret api_encryption

ota:
  platform: esphome
  password: !secret ota_password

captive_portal:

web_server:
  port: 80 

packages:
  device_base: !include packages/device_base.yaml

#######################################
# Configuration simplifiée avec impulse_cover #
#######################################

# Output pour le relais (remplace votre switch GPIO12)
output:
  - platform: gpio
    pin: GPIO12
    id: gate_relay_output

# Capteurs de fin de course et diagnostic
binary_sensor:
  # Capteur de porte fermée (votre GPIO4)
  - platform: gpio
    id: closed_sensor
    pin: 
      number: GPIO4
      inverted: false
    name: "Gate Closed Sensor"
    device_class: "garage_door"
    entity_category: "diagnostic"
    icon: "mdi:gate"
    filters:
      - delayed_on_off: 1s
      
  # Capteur d'obstruction (votre GPIO5)
  - platform: gpio
    pin: 
      number: GPIO5
      inverted: true
    name: "Gate Obstruction Sensor"
    device_class: problem
    entity_category: diagnostic
    filters:
      - delayed_on: 50ms

  # Capteur pour détecter les boucles de mouvement
  - platform: template
    name: "Gate Movement Loop Detection"
    device_class: problem
    entity_category: diagnostic
    lambda: |-
      // Utilise le compteur de mouvements
      return id(movement_counter).state >= 10;
    on_press:
      - logger.log:
          level: WARN
          format: "Movement loop detected! Gate may be obstructed."

# Capteurs de diagnostic
sensor:
  # Compteur de mouvements (maintenu depuis votre config)
  - platform: template
    id: "movement_counter"
    name: "Gate Movement Counter"
    update_interval: never
    internal: false
    entity_category: diagnostic
    unit_of_measurement: "moves"
    icon: "mdi:counter"
    filters: 
      - throttle: 2s
      - timeout:
          timeout: 10min
          value: 0

# Le composant impulse_cover remplace tous vos scripts !
cover:
  - platform: impulse_cover
    name: "${friendly_name}"
    id: gate_cover
    
    # Configuration de base
    output: gate_relay_output
    open_duration: 12s    # Durée d'ouverture (votre delay de 12s)
    close_duration: 20s   # Durée de fermeture (votre delay de 20s)
    
    # Configuration du pulse
    pulse_delay: 500ms    # Votre delay de 500ms
    
    # Sécurité (équivalent à votre détection de boucle)
    safety_timeout: 30s
    safety_max_cycles: 20  # Remplace votre détection à 10 mouvements
    
    # Capteurs de fin de course
    close_sensor: closed_sensor
    close_sensor_inverted: true  # Le capteur est actif quand ouvert
    
    # Automation triggers (remplacent vos scripts)
    on_open:
      - logger.log: "Gate opening started"
      - lambda: |-
          // Incrémenter le compteur de mouvements
          float state = 0.0f;
          if (!isnan(id(movement_counter).state)) {
            state = id(movement_counter).state;
          }
          id(movement_counter).publish_state(state + 1.0f);
        


